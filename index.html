<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gap to P1 by Lap — ECharts (manifest-driven)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root { --bg:#0f1115; --fg:#e8e8e8; --muted:#8b8b8b; --panel:#1a1d24; --border:#232833; }
    body { margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--fg); background:var(--bg); }
    header { padding:10px 14px; background:var(--panel); display:flex; gap:12px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--border); }
    .title { font-weight:600; margin-right:auto; }
    select { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; min-width: 320px; }
    .small { color:var(--muted); font-size:12px; }
    .layout { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 56px); }
    #sidebar { background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; }
    #sidebar .section { padding:12px; border-bottom:1px solid var(--border); }
    #driverList { padding:10px; overflow:auto; }
    .driver { display:flex; align-items:center; gap:8px; padding:4px 2px; border-radius:6px; }
    .driver:hover { background:#141820; }
    #chart { width:100%; height:100%; }
    .buttons { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .buttons button { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; cursor:pointer; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
  </style>
</head>
<body>
  <header>
    <div class="title">ECharts — Step Lines with End Labels</div>
    <!-- Dropdown populated from driver_lines_filenames.csv -->
    <select id="dataset" title="Choose dataset"></select>
    <span id="meta" class="small"></span>
  </header>

  <div class="layout">
    <aside id="sidebar">
      <div class="section">
        <div class="small">Drivers / lines</div>
        <div class="buttons">
          <button id="btnAll"  type="button">Select all</button>
          <button id="btnNone" type="button">Clear all</button>
        </div>
        <div class="hint">Toggle lines; y-axis rescales to visible series.</div>
      </div>
      <div id="driverList" aria-label="Driver list"></div>
    </aside>
    <main id="chart"></main>
  </div>

  <script>
    // ---------------- Core chart setup ----------------
    const chart = echarts.init(document.getElementById('chart'), null, { renderer: 'canvas' });
    window.addEventListener('resize', () => chart.resize());

    // Hidden legend drives selection state (checkboxes dispatch legend actions)
    const hiddenLegend = { show: false, selected: {} };

    // DOM refs
    const datasetSel = document.getElementById('dataset');
    const meta       = document.getElementById('meta');
    const driverList = document.getElementById('driverList');
    const btnAll     = document.getElementById('btnAll');
    const btnNone    = document.getElementById('btnNone');

    // State
    let currentSeriesNames = [];
    let lastYFallback = { min: -100, max: 1 }; // used if everything is hidden
    let manifestItems = [];                    // [{year,round_no,circuit,race,type,filename,label}, ...]

    // ---------------- CSV utilities ----------------
    // RFC4180-ish split for a single line (handles quoted commas and "" escapes)
    function splitCSVLine(line) {
      const out = []; let cur = ''; let inQ = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQ && line[i+1] === '"') { cur += '"'; i++; }
          else { inQ = !inQ; }
        } else if (ch === ',' && !inQ) {
          out.push(cur.trim()); cur = '';
        } else {
          cur += ch;
        }
      }
      out.push(cur.trim());
      return out;
    }

    function parseCSVToObjects(text) {
      const lines = text.split(/\r?\n/).filter(s => s.trim().length);
      if (!lines.length) return [];
      const header = splitCSVLine(lines[0]).map(h => h.toLowerCase());
      return lines.slice(1).map(line => {
        const cells = splitCSVLine(line);
        const obj = {};
        for (let i = 0; i < header.length; i++) obj[header[i]] = cells[i] ?? '';
        return obj;
      });
    }

    function parseDriverLines(csvText) {
      const lines = csvText.split(/\r?\n/).filter(s => s.trim().length);
      const rows = []; let lapCount = 0; const allY = [];
      for (const line of lines) {
        const cells = splitCSVLine(line);
        if (!cells.length) continue;
        const label = (cells[0] || '').trim();
        const nums = [];
        for (let i = 1; i < cells.length; i++) {
          const v = parseFloat(cells[i]);
          if (Number.isFinite(v)) nums.push(v);
        }
        if (!label || nums.length === 0) continue;
        lapCount = Math.max(lapCount, nums.length);
        allY.push(...nums);
        rows.push({ label, values: nums });
      }
      const minY = allY.length ? Math.min(...allY) : -100;
      const maxY = allY.length ? Math.max(...allY) : 1;
      return { rows, lapCount, minY, maxY };
    }

    // ---------------- ECharts option builders ----------------
    function buildOption(parsed, titleText) {
      const { rows, lapCount, minY, maxY } = parsed;
      const rightX = lapCount + 1.2;

      const series = [];
      hiddenLegend.selected = {};

      for (const { label, values } of rows) {
        const data = [];
        for (let i = 0; i < values.length; i++) data.push([i + 1, values[i]]);
        if (values.length) data.push([rightX, values[values.length - 1]]);
        hiddenLegend.selected[label] = true;

        series.push({
          name: label,
          type: 'line',
          data,
          step: 'end',
          showSymbol: false,
          lineStyle: { width: 1.8, opacity: 0.95 },
          emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.2 } },
          blur: { lineStyle: { opacity: 0.15 } },  // dim other series on hover
          endLabel: { show: true, formatter: '{a}', position: 'right', offset: [6,0], color: 'inherit' },
          progressive: 2000,
          animation: false,
          clip: true
        });
      }

      lastYFallback = {
        min: Math.min(-100, Math.floor(minY - 2)),
        max: Math.max(  1, Math.ceil (maxY + 1))
      };

      return {
        backgroundColor: 'transparent',
        title: { text: titleText || 'Gap to P1 by Lap', left: 'center', top: 6, textStyle: { color: '#e8e8e8', fontSize: 16, fontWeight: 600 } },
        grid: { left: 56, right: 130, top: 42, bottom: 40 },
        tooltip: { show: false },
        legend: hiddenLegend,
        xAxis: {
          type: 'value',
          min: 1,
          max: rightX + 0.1,
          name: 'Lap',
          nameLocation: 'middle',
          nameGap: 28,
          axisLabel: { color: '#c8c8c8', formatter: v => Number.isInteger(v) ? v : '' },
          splitLine: { lineStyle: { color: '#2a2f3a' } },
          axisLine: { lineStyle: { color: '#6b6f7b' } },
        },
        yAxis: {
          type: 'value',
          min: lastYFallback.min,
          max: lastYFallback.max,
          name: 'Gap to P1 (s)',
          nameLocation: 'middle',
          nameGap: 40,
          axisLabel: { color: '#c8c8c8' },
          splitLine: { lineStyle: { color: '#2a2f3a' } },
          axisLine: { lineStyle: { color: '#6b6f7b' } },
        },
        series: [
          ...series,
          { // baseline y=0
            name: '__baseline__',
            type: 'line',
            data: [[1, 0], [lapCount + 1.3, 0]],
            showSymbol: false,
            lineStyle: { width: 1, opacity: 0.35, color: '#aaaaaa' },
            silent: true,
            z: -1
          }
        ]
      };
    }

    // Recompute y-axis to visible series
    function updateYAxisToVisible() {
      const opt = chart.getOption();
      const legendSel = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
      const series = (opt.series || []).filter(s =>
        s.type === 'line' && s.name !== '__baseline__' && (legendSel[s.name] !== false)
      );
      let min = Infinity, max = -Infinity;
      for (const s of series) {
        for (const pt of s.data) {
          const y = Array.isArray(pt) ? pt[1] : (pt && pt.value ? pt.value[1] : null);
          if (Number.isFinite(y)) { if (y < min) min = y; if (y > max) max = y; }
        }
      }
      if (!series.length || !Number.isFinite(min) || !Number.isFinite(max)) {
        chart.setOption({ yAxis: { min: lastYFallback.min, max: lastYFallback.max } });
        return;
      }
      const span = Math.max(1e-6, max - min);
      const pad  = Math.max(0.02 * span, 0.5);
      const yMin = Math.min(min - pad, 0);   // keep baseline visible
      const yMax = Math.max(max + pad, 0.5);
      chart.setOption({ yAxis: { min: Math.floor(yMin), max: Math.ceil(yMax) } });
    }
    chart.on('legendselectchanged', updateYAxisToVisible); // backup

    // ---------------- Sidebar: line toggles ----------------
    function buildDriverList(names) {
      driverList.innerHTML = '';
      const sel = ((chart.getOption().legend || [])[0] || {}).selected || {};
      for (const name of names.slice().sort()) {
        const row = document.createElement('label');
        row.className = 'driver';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = sel[name] !== false;
        cb.addEventListener('change', () => {
          chart.dispatchAction({ type: cb.checked ? 'legendSelect' : 'legendUnSelect', name });
          updateYAxisToVisible(); // immediate rescale
        });
        row.appendChild(cb);
        row.appendChild(document.createTextNode(' ' + name));
        driverList.appendChild(row);
      }
    }

    function syncCheckboxes(val) {
      const boxes = driverList.querySelectorAll('input[type="checkbox"]');
      boxes.forEach(b => b.checked = val);
    }
    btnAll.addEventListener('click', () => {
      for (const name of currentSeriesNames) chart.dispatchAction({ type: 'legendSelect', name });
      updateYAxisToVisible(); syncCheckboxes(true);
    });
    btnNone.addEventListener('click', () => {
      for (const name of currentSeriesNames) chart.dispatchAction({ type: 'legendUnSelect', name });
      updateYAxisToVisible(); syncCheckboxes(false);
    });

    // ---------------- Manifest + dataset loading ----------------
    async function loadManifest() {
      datasetSel.disabled = true;
      datasetSel.innerHTML = '<option>Loading…</option>';
      try {
        const text = await fetch('driver_lines_filenames.csv', { cache: 'no-store' }).then(r => r.text());
        const objs = parseCSVToObjects(text);
        // Expect columns: year, round_no, circuit, race, type, filename
        manifestItems = objs
          .filter(o => (o.filename || '').trim().length)
          .map(o => {
            const label =
              `${o.year || ''} • Round ${o.round_no || ''} • ${o.circuit || ''} • ${o.type || ''}${o.race ? ' • ' + o.race : ''}`;
            return { ...o, label, filename: o.filename.trim() };
          });

        datasetSel.innerHTML = '';
        for (const item of manifestItems) {
          const opt = document.createElement('option');
          opt.value = item.filename;
          opt.textContent = item.label;
          datasetSel.appendChild(opt);
        }
        datasetSel.disabled = manifestItems.length === 0;

        if (manifestItems.length) {
          await loadCsvAndPlot(manifestItems[0].filename, manifestItems[0].label);
        } else {
          meta.textContent = 'No entries in driver_lines_filenames.csv';
        }
      } catch (e) {
        datasetSel.innerHTML = '<option>Error loading manifest</option>';
        meta.textContent = 'Failed to load driver_lines_filenames.csv';
        console.error(e);
      }
    }

    datasetSel.addEventListener('change', async () => {
      const idx = datasetSel.selectedIndex;
      if (idx < 0) return;
      const item = manifestItems[idx];
      await loadCsvAndPlot(item.filename, item.label);
    });

    async function loadCsvAndPlot(path, labelForTitle) {
      const csv = await fetch(path, { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status} for ${path}`);
        return r.text();
      });
      const parsed = parseDriverLines(csv);
      const option = buildOption(parsed, labelForTitle || path.replace(/\.[^.]+$/, ''));
      chart.setOption(option, true);
      currentSeriesNames = parsed.rows.map(r => r.label);
      buildDriverList(currentSeriesNames);
      meta.textContent = `Dataset: ${labelForTitle || path} • Laps: ${parsed.lapCount} • Lines: ${currentSeriesNames.length}`;
      updateYAxisToVisible(); // initial fit
    }

    // ---------------- Boot ----------------
    chart.setOption({
      backgroundColor: 'transparent',
      title: { text: 'Loading datasets…', left: 'center', top: 'center', textStyle: { color: '#6b6f7b', fontWeight: 500 } },
      grid: { left: 56, right: 130, top: 42, bottom: 40 },
      xAxis: { type: 'value', min: 1, max: 10, axisLabel: { color: '#c8c8c8' } },
      yAxis: { type: 'value', min: -100, max: 1, axisLabel: { color: '#c8c8c8' } },
      legend: hiddenLegend
    });
    window.addEventListener('DOMContentLoaded', loadManifest);
  </script>
</body>
</html>
