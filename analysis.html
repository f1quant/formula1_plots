<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>F1 Race Analysis</title>
  <link rel="stylesheet" href="common.css">
  <style>
    /* Page-specific styles */
    .page-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px;
    }

    .container {
      max-width: 1400px;
      width: 100%;
    }

    /* Tab Navigation */
    .tab-navigation {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      border-bottom: 2px solid var(--border-color);
      align-items: center;
    }

    .tab-button {
      padding: 12px 24px;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      color: var(--muted-color);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: -2px;
    }

    .tab-button:hover {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.03);
    }

    .tab-button.active {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
    }

    .tab-navigation .status-message {
      margin-left: auto;
      font-size: 12px;
      color: var(--muted-color);
      padding: 0 12px;
    }

    .tab-navigation #reloadDataBtn {
      margin-bottom: -2px;
      padding: 8px 16px;
      font-size: 12px;
    }

    /* Session Selector */
    .session-selector {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .small {
      color: var(--muted-color);
      font-size: 12px;
    }

    select {
      min-width: 160px;
      width: auto;
    }

    #sessionSel {
      min-width: 120px;
    }

    /* Content Panels */
    .content-panel {
      display: none;
    }

    .content-panel.active {
      display: block;
    }

    /* ========================================================================
       STRATEGY PANEL STYLES
       ======================================================================== */

    #strategy-panel {
      display: flex;
      justify-content: center;
    }

    .strategy-container {
      max-width: 900px;
      width: 100%;
      margin-top: 20px;
      padding: 20px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      display: none;
    }

    .strategy-container.show {
      display: block;
    }

    .driver-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative;
    }

    .driver-label {
      width: 80px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-color);
      text-align: right;
      padding-right: 12px;
      flex-shrink: 0;
    }

    .strategy-bar {
      flex: 1;
      height: 24px;
      display: flex;
      position: relative;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      overflow: hidden;
    }

    .stint-segment {
      height: 100%;
      position: relative;
      border-right: 3px solid #000;
      box-shadow: 2px 0 0 rgba(0, 0, 0, 0.8);
    }

    .stint-segment:last-child {
      border-right: none;
      box-shadow: none;
    }

    .missing-laps {
      height: 100%;
      background: repeating-linear-gradient(
        45deg,
        #333,
        #333 4px,
        #222 4px,
        #222 8px
      );
      opacity: 0.5;
    }

    .lap-axis {
      display: flex;
      align-items: center;
      position: relative;
    }

    .lap-axis.top {
      margin-bottom: 8px;
    }

    .lap-axis.bottom {
      margin-top: 16px;
    }

    .lap-axis-spacer {
      width: 80px;
      flex-shrink: 0;
    }

    .lap-axis-track {
      flex: 1;
      height: 30px;
      position: relative;
      border-top: 1px solid var(--border-color);
    }

    .lap-axis.bottom .lap-axis-track {
      border-top: 1px solid var(--border-color);
      border-bottom: none;
    }

    .lap-axis.top .lap-axis-track {
      border-top: none;
      border-bottom: 1px solid var(--border-color);
    }

    .lap-tick {
      position: absolute;
      width: 1px;
      background: var(--muted-color);
    }

    .lap-axis.bottom .lap-tick {
      top: 0;
      height: 8px;
    }

    .lap-axis.top .lap-tick {
      bottom: 0;
      height: 8px;
    }

    .lap-label {
      position: absolute;
      font-size: 10px;
      color: var(--muted-color);
      transform: translateX(-50%);
    }

    .lap-axis.bottom .lap-label {
      top: 10px;
    }

    .lap-axis.top .lap-label {
      bottom: 10px;
    }

    .tooltip {
      position: absolute;
      background: rgba(26, 29, 36, 0.96);
      border: 1px solid var(--accent-color);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text-color);
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .tooltip.show {
      display: block;
    }

    /* Hide the common.js navigation since we have our own tabs */
    nav {
      display: none !important;
    }

    /* ========================================================================
       RACE TRACE PANEL STYLES
       ======================================================================== */

    .race-trace-controls {
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid var(--border-color);
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .race-trace-controls-row {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }

    .race-trace-controls-box {
      display: flex;
      gap: 8px;
      padding: 10px 14px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      align-items: center;
    }

    .race-trace-controls input[type="number"] {
      width: 90px;
    }

    .race-trace-controls-box input[type="number"] {
      width: 90px;
    }

    .race-trace-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 600px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .race-trace-sidebar {
      background: rgba(255, 255, 255, 0.02);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }

    .race-trace-sidebar .section {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .race-trace-sidebar .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    #raceTraceDriverList {
      padding: 10px;
      overflow: auto;
    }

    .race-trace-driver {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 2px;
      border-radius: 6px;
    }

    .race-trace-driver:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .race-trace-driver label {
      cursor: pointer;
      user-select: none;
    }

    #raceTraceChart {
      width: 100%;
      height: 100%;
      min-height: 600px;
    }

    .race-trace-debug-info {
      padding: 20px;
      color: var(--text-color);
      font-size: 14px;
    }

    /* ========================================================================
       LAP TIME PANEL STYLES
       ======================================================================== */

    .lap-time-layout {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
    }

    .lap-time-sidebar {
      width: 200px;
      padding: 12px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      max-height: 610px;
      overflow-y: auto;
    }

    .lap-time-chart-wrapper {
      flex: 1;
    }

    .lap-time-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .toggle-button {
      padding: 4px 12px;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toggle-button.active {
      background: var(--accent-color);
      color: #000;
      border-color: var(--accent-color);
    }

    .toggle-button:hover {
      border-color: var(--accent-color);
    }

    #lapTimeChart {
      width: 100%;
      height: 610px;
    }

    .lap-time-filters {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }

    .filter-panel {
      padding: 16px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .filters-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .drivers-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filters-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .filter-label {
      font-size: 10px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .filter-item input[type="number"] {
      width: 100px;
    }

    .exclude-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .checkbox-group label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
    }

    .lap-time-driver-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
    }

    .lap-time-driver-item:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .lap-time-driver-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .lap-time-driver-item label {
      cursor: pointer;
      flex: 1;
    }
  </style>
</head>
<body>
  <div class="page-content">
  <div class="container">
    <!-- Tab Navigation -->
    <div class="tab-navigation">
      <button class="tab-button active" data-tab="strategy">Strategy</button>
      <button class="tab-button" data-tab="race-trace">Race Trace</button>
      <button class="tab-button" data-tab="lap-time">Lap Time</button>
      <button class="tab-button" data-tab="tyre-deg">Tyre Degradation</button>
      <button class="tab-button" data-tab="fuel-effect">Fuel Effect</button>
      <span class="status-message" id="statusMessage">Loading...</span>
      <button id="reloadDataBtn" type="button" title="Reload data from server">Reload Data</button>
    </div>

    <!-- Session Selector (shared across all tabs) -->
    <div class="session-selector">
      <label class="small" for="seasonSel">Season</label>
      <select id="seasonSel" title="Season">
        <option value=""></option>
      </select>
      <label class="small" for="gpSel">GP</label>
      <select id="gpSel" title="Grand Prix" disabled>
        <option value=""></option>
      </select>
      <label class="small" for="sessionSel">Session</label>
      <select id="sessionSel" title="Session type" disabled>
        <option value=""></option>
      </select>
    </div>

    <!-- Strategy Panel -->
    <div id="strategy-panel" class="content-panel active">
      <div id="strategyContainer" class="strategy-container">
        <div class="lap-axis top">
          <div class="lap-axis-spacer"></div>
          <div class="lap-axis-track" id="lapAxisTop"></div>
        </div>
        <div id="strategyChart"></div>
        <div class="lap-axis bottom">
          <div class="lap-axis-spacer"></div>
          <div class="lap-axis-track" id="lapAxisBottom"></div>
        </div>
      </div>
    </div>

    <!-- Race Trace Panel -->
    <div id="race-trace-panel" class="content-panel">
      <div class="race-trace-controls-row">
        <div class="race-trace-controls-box">
          <button id="raceTraceBtnAll" type="button">Select all</button>
          <button id="raceTraceBtnNone" type="button">Clear all</button>
        </div>
        <div class="race-trace-controls-box">
          <label class="small" for="raceTraceLapMin">Lap min</label>
          <input id="raceTraceLapMin" type="number" min="1" step="1" value="1" title="Min lap" />
          <label class="small" for="raceTraceLapMax">Lap max</label>
          <input id="raceTraceLapMax" type="number" min="1" step="1" value="1" title="Max lap" />
        </div>
      </div>

      <div class="race-trace-layout">
        <aside class="race-trace-sidebar">
          <div id="raceTraceDriverList" aria-label="Driver list"></div>
        </aside>
        <main id="raceTraceChart">
          <div class="race-trace-debug-info" id="raceTraceDebugInfo">
            Waiting for data...
          </div>
        </main>
      </div>
    </div>

    <!-- Lap Time Panel -->
    <div id="lap-time-panel" class="content-panel">
      <div class="lap-time-layout">
        <div class="lap-time-sidebar">
          <div id="lapTimeDriversList"></div>
        </div>
        <div class="lap-time-chart-wrapper">
          <div class="lap-time-controls">
            <button id="fuelAdjustToggle" class="toggle-button">Fuel Adjusted</button>
            <button id="tyreLifeAdjustToggle" class="toggle-button">Tyre Life Adjusted</button>
          </div>
          <div id="lapTimeChart"></div>
        </div>
      </div>

      <div class="lap-time-filters">
        <div class="filter-panel">
          <div class="filters-title">Adjustments</div>
          <div class="filters-grid">
            <div class="filter-item">
              <div class="filter-label">Hard Deg (sec/lap)</div>
              <input type="number" id="degHard" value="0.05" min="0" step="0.01">
            </div>
            <div class="filter-item">
              <div class="filter-label">Medium Deg (sec/lap)</div>
              <input type="number" id="degMedium" value="0.08" min="0" step="0.01">
            </div>
            <div class="filter-item">
              <div class="filter-label">Soft Deg (sec/lap)</div>
              <input type="number" id="degSoft" value="0.12" min="0" step="0.01">
            </div>
            <div class="filter-item">
              <div class="filter-label">Fuel Effect (sec/lap)</div>
              <input type="number" id="fuelEffect" value="0.03" min="0" step="0.01">
            </div>
          </div>
        </div>

        <div class="filter-panel">
          <div class="filters-title">Lap Filters</div>
          <div class="filters-grid">
            <div class="filter-item">
              <div class="filter-label">Laps to Discard at Start</div>
              <input type="number" id="filterMinLap" value="2" min="0">
            </div>
            <div class="filter-item">
              <div class="filter-label">Laps to Discard at End</div>
              <input type="number" id="filterEndLaps" value="0" min="0">
            </div>
            <div class="filter-item">
              <div class="filter-label">Min Distance to Car Ahead</div>
              <input type="number" id="filterMinDist" value="0" min="0" step="0.1">
            </div>
          </div>
        </div>

        <div class="filter-panel">
          <div class="filters-title">Include</div>
          <div class="exclude-checkboxes">
            <div class="checkbox-group">
              <input type="checkbox" id="filterIncludeLapped" checked>
              <label for="filterIncludeLapped">Lapped</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterIncludeRetired" checked>
              <label for="filterIncludeRetired">Retired</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterRainfall" checked>
              <label for="filterRainfall">Rainfall</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterSafetyCar">
              <label for="filterSafetyCar">Safety Car</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterPitLaps">
              <label for="filterPitLaps">Pit Laps</label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tyre Degradation Panel -->
    <div id="tyre-deg-panel" class="content-panel">
      <h2>Tyre Degradation Panel</h2>
      <p>Tyre degradation content will go here...</p>
    </div>

    <!-- Fuel Effect Panel -->
    <div id="fuel-effect-panel" class="content-panel">
      <h2>Fuel Effect Panel</h2>
      <p>Fuel effect content will go here...</p>
    </div>

  </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>

  <script>
    // ============================================================================
    // SHARED STATE AND ELEMENTS
    // ============================================================================

    const seasonSel = document.getElementById("seasonSel");
    const gpSel = document.getElementById("gpSel");
    const sessionSel = document.getElementById("sessionSel");
    const statusMessage = document.getElementById("statusMessage");
    const reloadDataBtn = document.getElementById("reloadDataBtn");

    let allRows = [];
    let sessionsByKey = new Map();
    let currentSessionData = null; // Stores filtered data for current session
    let currentActiveTab = 'strategy';
    let selectedDrivers = new Set(); // Shared driver selection across race trace and lap time panels

    // ============================================================================
    // TAB SWITCHING
    // ============================================================================

    function initTabNavigation() {
      const tabButtons = document.querySelectorAll('.tab-button');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tabName = button.dataset.tab;
          switchTab(tabName);
        });
      });
    }

    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
      });

      // Update panels
      document.querySelectorAll('.content-panel').forEach(panel => {
        panel.classList.remove('active');
      });
      document.getElementById(`${tabName}-panel`).classList.add('active');

      // Hide strategy container when switching away from strategy
      if (tabName !== 'strategy') {
        strategyContainer.classList.remove('show');
      }

      currentActiveTab = tabName;

      // Initialize panel if data is available
      if (currentSessionData) {
        initializePanel(tabName, currentSessionData);
      }
    }

    function initializePanel(panelName, sessionData) {
      if (!sessionData || sessionData.length === 0) return;

      console.log(`Initializing ${panelName} panel with ${sessionData.length} rows`);

      // Get current session info
      const year = seasonSel.value;
      const [round, meeting] = gpSel.value.split('||');
      const sessionType = sessionSel.value;

      switch(panelName) {
        case 'strategy':
          renderStrategyChart(sessionData, year, round, sessionType);
          break;
        case 'race-trace':
          raceTraceCurrentSessionRows = sessionData;
          raceTraceYear = year;
          raceTraceRound = round;
          raceTraceSessionType = sessionType;
          raceTraceDriverColors = DriverInfo.getDriverColors(year, round, sessionType);
          const lapNumbers = sessionData.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n));
          const minLapNum = Math.min(...lapNumbers);
          const maxLapNum = Math.max(...lapNumbers);
          raceTraceLapMin.value = minLapNum;
          raceTraceLapMax.value = maxLapNum;
          raceTraceLapMin.min = minLapNum;
          raceTraceLapMax.max = maxLapNum;
          calculateRaceTraceGaps(sessionData);
          buildRaceTraceDriverList();

          // Auto-select top 5 drivers for new session
          if (selectedDrivers.size === 0) {
            const drivers = Object.keys(raceTraceDriverLines);
            const driverFinishInfo = drivers.map(driver => {
              const data = raceTraceDriverLines[driver];
              const maxLapNum = Math.max(...data.laps);
              const lastLapIndex = data.laps.indexOf(maxLapNum);
              const lastPosition = data.positions[lastLapIndex];
              return { driver, maxLapNum, lastPosition };
            });
            const sortedDrivers = sortDriversByFinishingOrder(driverFinishInfo);
            sortedDrivers.slice(0, 5).forEach(({ driver }) => {
              selectedDrivers.add(driver);
            });
          }

          // Update checkboxes to reflect current selection
          updateRaceTraceDriverCheckboxes();
          renderRaceTraceChart();
          break;
        case 'lap-time':
          // Initialize lap time panel
          lapTimeCurrentSessionRows = sessionData;
          lapTimeYear = year;
          lapTimeRound = round;
          lapTimeSessionType = sessionType;
          lapTimeDriverColors = DriverInfo.getDriverColors(year, round, sessionType);
          lapTimeScheduledLaps = sessionData.length > 0 ? parseInt(sessionData[0].sched_laps) : null;
          if (isNaN(lapTimeScheduledLaps)) {
            lapTimeScheduledLaps = null;
          }

          // Update adjustment inputs from circuit config if available
          const circuitName = sessionData.length > 0 ? String(sessionData[0].circuit_name || "").trim() : "";
          if (circuitName && circuitConfig[circuitName]) {
            const config = circuitConfig[circuitName];
            if (config["Hard Deg"] !== undefined) {
              document.getElementById('degHard').value = config["Hard Deg"];
            }
            if (config["Medium Deg"] !== undefined) {
              document.getElementById('degMedium').value = config["Medium Deg"];
            }
            if (config["Soft Deg"] !== undefined) {
              document.getElementById('degSoft').value = config["Soft Deg"];
            }
            if (config["Fuel Effect"] !== undefined) {
              document.getElementById('fuelEffect').value = config["Fuel Effect"];
            }
          }

          const filteredRows = applyLapTimeFilters(sessionData);
          processLapTimeData(filteredRows);

          // Auto-select top 5 drivers for new session (if not already selected)
          if (selectedDrivers.size === 0 && lapTimeCurrentGroups.size > 0) {
            const drivers = Array.from(lapTimeCurrentGroups.keys());
            const top5 = drivers.slice(0, Math.min(5, drivers.length));
            top5.forEach(driver => selectedDrivers.add(driver));
            // Re-render to show the selected drivers
            buildLapTimeDriversList(drivers);
            renderLapTimeChart();
          }
          break;
        case 'tyre-deg':
          // Initialize tyre deg panel
          break;
        case 'fuel-effect':
          // Initialize fuel effect panel
          break;
      }
    }

    // ============================================================================
    // SHARED DATA LOADING
    // ============================================================================

    function init() {
      initTabNavigation();

      // Set up reload data button
      reloadDataBtn.addEventListener('click', () => {
        DataCache.reloadData();
      });

      DriverInfo.load(loadMainCSV);
    }

    function loadMainCSV() {
      ParsedDataCache.loadCSV("all_df.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.session_type !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          indexSessions(allRows);
          buildSeasonDropdown();
          statusMessage.textContent = `${allRows.length} laps loaded`;
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      seasonSel.addEventListener("change", onSeasonChange);
      gpSel.addEventListener("change", onGPChange);
      sessionSel.addEventListener("change", onSessionChange);
    }

    function indexSessions(rows) {
      sessionsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const sessionType = String(r.session_type || "").trim();
        const circuit = String(r.circuit_name || "").trim();
        if (!year || !round || !meeting || !sessionType || !circuit) return;

        const key = `${year}||${round}||${meeting}||${sessionType}`;
        if (!sessionsByKey.has(key)) {
          sessionsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            session_type: sessionType,
            circuit_name: circuit
          });
        }
      });
    }

    function buildSeasonDropdown() {
      UIHelpers.populateSeasons(seasonSel, sessionsByKey, {
        onChange: onSeasonChange
      });
    }

    function onSeasonChange() {
      const selectedSeason = seasonSel.value;
      sessionSel.innerHTML = '';
      sessionSel.disabled = true;

      currentSessionData = null;

      UIHelpers.populateGPs(gpSel, sessionsByKey, selectedSeason, {
        onChange: onGPChange
      });
    }

    function onGPChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;

      currentSessionData = null;

      UIHelpers.populateSessions(sessionSel, sessionsByKey, selectedSeason, selectedGP, {
        onChange: onSessionChange
      });
    }

    function onSessionChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        currentSessionData = null;
        return;
      }

      const [round, meeting] = selectedGP.split('||');

      // Filter data for this session (shared across all tabs)
      currentSessionData = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      // Clear selected drivers when a new session is selected
      selectedDrivers.clear();

      // Initialize the currently active panel with new data
      if (currentSessionData.length > 0) {
        initializePanel(currentActiveTab, currentSessionData);
      }
    }

    // ============================================================================
    // PANEL-SPECIFIC CODE SECTIONS
    // ============================================================================

    // Strategy Panel
    const strategyChart = document.getElementById('strategyChart');
    const strategyContainer = document.getElementById('strategyContainer');
    const lapAxisTop = document.getElementById('lapAxisTop');
    const lapAxisBottom = document.getElementById('lapAxisBottom');
    const tooltip = document.getElementById('tooltip');

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();
      const colorMap = {
        'soft': '#FF0000',
        'medium': '#FFF200',
        'hard': '#FFFFFF',
        'intermediate': '#00FF00',
        'wet': '#0000FF'
      };
      return colorMap[compoundLower] || '#999999';
    }

    function updateTooltipPosition(e) {
      const x = e.clientX;
      const y = e.clientY;
      tooltip.style.left = `${x + 15}px`;
      tooltip.style.top = `${y + 15}px`;
    }

    function renderStrategyChart(rows, year, round, sessionType) {
      // Get driver colors for this specific session
      const driverColors = DriverInfo.getDriverColors(year, round, sessionType);

      // Group by driver
      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNum = parseInt(r.lap_LapNumber);
        const stint = parseInt(r.lap_Stint);
        const compound = String(r.lap_Compound || "").trim();
        const gridPos = parseInt(r.grid_position);
        const tyreLife = parseInt(r.lap_TyreLife);
        const position = parseInt(r.lap_Position);

        if (!driver || isNaN(lapNum)) return;

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            gridPosition: gridPos,
            laps: new Map(),
            stints: new Map(),
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverData.get(driver);
        data.laps.set(lapNum, { compound, stint, tyreLife, position });

        // Track max lap number and position on that lap
        if (lapNum > data.maxLapNum) {
          data.maxLapNum = lapNum;
          data.lastPosition = position;
        }

        if (!data.stints.has(stint)) {
          data.stints.set(stint, {
            compound: compound,
            startLap: lapNum,
            endLap: lapNum,
            startTyreLife: tyreLife
          });
        } else {
          const stintData = data.stints.get(stint);
          if (lapNum < stintData.startLap) {
            stintData.startLap = lapNum;
            stintData.startTyreLife = tyreLife;
          }
          if (lapNum > stintData.endLap) {
            stintData.endLap = lapNum;
          }
        }
      });

      // Get max lap number (scheduled laps)
      const schedLaps = parseInt(rows[0]?.sched_laps || 0);
      const maxLap = schedLaps > 0 ? schedLaps : Math.max(...Array.from(driverData.values()).flatMap(d => Array.from(d.laps.keys())));

      // Sort drivers by finishing position using shared utility
      const sortedDrivers = sortDriversByFinishingOrder(Array.from(driverData.values()));

      // Clear chart
      strategyChart.innerHTML = '';

      // Render driver rows
      sortedDrivers.forEach(data => {
        const row = document.createElement('div');
        row.className = 'driver-row';

        const label = document.createElement('div');
        label.className = 'driver-label';
        label.textContent = data.driver;

        // Apply driver color if available
        const driverColor = driverColors.get(data.driver);
        if (driverColor) {
          label.style.color = driverColor;
        }

        const bar = document.createElement('div');
        bar.className = 'strategy-bar';

        // Build stint segments
        const sortedStints = Array.from(data.stints.values()).sort((a, b) => a.startLap - b.startLap);

        sortedStints.forEach((stint, idx) => {
          const segment = document.createElement('div');
          segment.className = 'stint-segment';
          const stintLaps = stint.endLap - stint.startLap + 1;
          const widthPercent = (stintLaps / maxLap) * 100;
          segment.style.width = `${widthPercent}%`;
          segment.style.backgroundColor = getF1TireColor(stint.compound);

          // Add tooltip
          segment.addEventListener('mouseenter', (e) => {
            const tyreAgeText = !isNaN(stint.startTyreLife) ? `<br/>Tyre age at start: ${stint.startTyreLife} laps` : '';
            tooltip.innerHTML = `
              <strong>${data.driver}</strong><br/>
              Stint ${idx + 1}: ${stint.compound}<br/>
              Laps ${stint.startLap}-${stint.endLap} (${stintLaps} laps)${tyreAgeText}
            `;
            tooltip.classList.add('show');
            updateTooltipPosition(e);
          });

          segment.addEventListener('mousemove', updateTooltipPosition);

          segment.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show');
          });

          bar.appendChild(segment);
        });

        // Add missing laps if driver didn't complete all laps
        const lastLap = Math.max(...Array.from(data.laps.keys()));
        if (lastLap < maxLap) {
          const missingLaps = maxLap - lastLap;
          const widthPercent = (missingLaps / maxLap) * 100;
          const missing = document.createElement('div');
          missing.className = 'missing-laps';
          missing.style.width = `${widthPercent}%`;
          bar.appendChild(missing);
        }

        row.appendChild(label);
        row.appendChild(bar);
        strategyChart.appendChild(row);
      });

      // Render lap axes
      renderLapAxis(maxLap);

      // Show the container
      strategyContainer.classList.add('show');
    }

    function renderLapAxis(maxLap) {
      lapAxisTop.innerHTML = '';
      lapAxisBottom.innerHTML = '';

      // Create tick marks at intervals
      const interval = maxLap > 50 ? 10 : 5;

      for (let lap = 0; lap <= maxLap; lap += interval) {
        // Top axis
        const tickTop = document.createElement('div');
        tickTop.className = 'lap-tick';
        const position = (lap / maxLap) * 100;
        tickTop.style.left = `${position}%`;
        lapAxisTop.appendChild(tickTop);

        const labelTop = document.createElement('div');
        labelTop.className = 'lap-label';
        labelTop.textContent = lap;
        labelTop.style.left = `${position}%`;
        lapAxisTop.appendChild(labelTop);

        // Bottom axis
        const tickBottom = document.createElement('div');
        tickBottom.className = 'lap-tick';
        tickBottom.style.left = `${position}%`;
        lapAxisBottom.appendChild(tickBottom);

        const labelBottom = document.createElement('div');
        labelBottom.className = 'lap-label';
        labelBottom.textContent = lap;
        labelBottom.style.left = `${position}%`;
        lapAxisBottom.appendChild(labelBottom);
      }
    }

    // Race Trace Panel
    const raceTraceLapMin = document.getElementById('raceTraceLapMin');
    const raceTraceLapMax = document.getElementById('raceTraceLapMax');
    const raceTraceDriverList = document.getElementById('raceTraceDriverList');
    const raceTraceBtnAll = document.getElementById('raceTraceBtnAll');
    const raceTraceBtnNone = document.getElementById('raceTraceBtnNone');
    const raceTraceDebugInfo = document.getElementById('raceTraceDebugInfo');

    let raceTraceDriverLines = {};
    let raceTraceChart = null;
    let raceTraceCurrentSessionRows = [];
    let raceTraceDriverColors = new Map();
    let raceTraceYear = '';
    let raceTraceRound = '';
    let raceTraceSessionType = '';

    // Set up race trace event listeners
    raceTraceBtnAll.addEventListener('click', () => {
      selectedDrivers.clear();
      Object.keys(raceTraceDriverLines).forEach(d => selectedDrivers.add(d));
      updateRaceTraceDriverCheckboxes();
      renderRaceTraceChart();
    });

    raceTraceBtnNone.addEventListener('click', () => {
      selectedDrivers.clear();
      updateRaceTraceDriverCheckboxes();
      renderRaceTraceChart();
    });

    raceTraceLapMin.addEventListener('input', () => renderRaceTraceChart());
    raceTraceLapMax.addEventListener('input', () => renderRaceTraceChart());

    function getDriverInfo(code) {
      // Get driver info for current session with proper parameters
      if (!raceTraceYear || !raceTraceRound || !raceTraceSessionType) {
        return { fullName: code, color: '#888888', teamName: '', headshotUrl: '' };
      }

      return DriverInfo.getDriverInfo(code, raceTraceYear, raceTraceRound, raceTraceSessionType);
    }

    function calculateRaceTraceGaps(rows) {
      const lapData = new Map();

      rows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        const driver = String(r.lap_Driver || "").trim();
        const position = parseInt(r.lap_Position);
        const lapTime = parseFloat(r.lap_Time);

        if (isNaN(lapNum) || !driver || isNaN(lapTime) || isNaN(position)) return;

        if (!lapData.has(lapNum)) {
          lapData.set(lapNum, []);
        }

        lapData.get(lapNum).push({ driver, position, lapTime });
      });

      raceTraceDriverLines = {};

      lapData.forEach((driversInLap, lapNum) => {
        driversInLap.sort((a, b) => a.position - b.position);
        const minTime = Math.min(...driversInLap.map(d => d.lapTime));

        driversInLap.forEach(d => {
          const gap = minTime - d.lapTime;

          if (!raceTraceDriverLines[d.driver]) {
            raceTraceDriverLines[d.driver] = {
              laps: [],
              gaps: [],
              positions: []
            };
          }

          raceTraceDriverLines[d.driver].laps.push(lapNum);
          raceTraceDriverLines[d.driver].gaps.push(gap);
          raceTraceDriverLines[d.driver].positions.push(d.position);
        });
      });
    }

    function buildRaceTraceDriverList() {
      raceTraceDriverList.innerHTML = '';

      const drivers = Object.keys(raceTraceDriverLines);
      const driverFinishInfo = drivers.map(driver => {
        const data = raceTraceDriverLines[driver];
        const maxLapNum = Math.max(...data.laps);
        const lastLapIndex = data.laps.indexOf(maxLapNum);
        const lastPosition = data.positions[lastLapIndex];

        return { driver, maxLapNum, lastPosition };
      });

      const sortedDriverFinishInfo = sortDriversByFinishingOrder(driverFinishInfo);

      sortedDriverFinishInfo.forEach(({ driver }) => {
        const div = document.createElement('div');
        div.className = 'race-trace-driver';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `race-trace-driver-${driver}`;
        checkbox.checked = selectedDrivers.has(driver);

        const info = getDriverInfo(driver);
        checkbox.style.accentColor = info.color;

        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }
          renderRaceTraceChart();
          // Also update lap time chart if it has data
          if (lapTimeCurrentGroups.size > 0) {
            renderLapTimeChart();
          }
        });

        const label = document.createElement('label');
        label.htmlFor = `race-trace-driver-${driver}`;

        // Format: "Full Name (ABB)"
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        label.textContent = displayName;
        label.style.color = info.color;

        div.appendChild(checkbox);
        div.appendChild(label);
        raceTraceDriverList.appendChild(div);
      });
    }

    function updateRaceTraceDriverCheckboxes() {
      Object.keys(raceTraceDriverLines).forEach(driver => {
        const checkbox = document.getElementById(`race-trace-driver-${driver}`);
        if (checkbox) {
          checkbox.checked = selectedDrivers.has(driver);
        }
      });
    }

    // Shared detection functions that work with any session rows
    function detectRainfallLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapRainfall = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRainfall.has(lapNum)) {
          lapRainfall.set(lapNum, { total: 0, rainfall: 0 });
        }

        const lapData = lapRainfall.get(lapNum);
        lapData.total++;

        const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
        if (rainfall === 'true' || rainfall === '1') {
          lapData.rainfall++;
        }
      });

      const rainfallLaps = [];
      lapRainfall.forEach((data, lapNum) => {
        if (data.rainfall / data.total >= 0.5) {
          rainfallLaps.push(lapNum);
        }
      });

      if (rainfallLaps.length === 0) return [];

      rainfallLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = rainfallLaps[0];
      let end = rainfallLaps[0];

      for (let i = 1; i < rainfallLaps.length; i++) {
        if (rainfallLaps[i] === end + 1) {
          end = rainfallLaps[i];
        } else {
          ranges.push({ start, end });
          start = rainfallLaps[i];
          end = rainfallLaps[i];
        }
      }
      ranges.push({ start, end });
      return ranges;
    }

    function detectSafetyCarLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapSafetyCar = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapSafetyCar.has(lapNum)) {
          lapSafetyCar.set(lapNum, { total: 0, safetyCar: 0 });
        }

        const lapData = lapSafetyCar.get(lapNum);
        lapData.total++;

        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('4') || trackStatus.includes('6') || trackStatus.includes('7')) {
          if (!trackStatus.includes('5')) {
            lapData.safetyCar++;
          }
        }
      });

      const safetyCarLaps = [];
      lapSafetyCar.forEach((data, lapNum) => {
        if (data.safetyCar / data.total >= 0.5) {
          safetyCarLaps.push(lapNum);
        }
      });

      if (safetyCarLaps.length === 0) return [];

      safetyCarLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = safetyCarLaps[0];
      let end = safetyCarLaps[0];

      for (let i = 1; i < safetyCarLaps.length; i++) {
        if (safetyCarLaps[i] === end + 1) {
          end = safetyCarLaps[i];
        } else {
          ranges.push({ start, end });
          start = safetyCarLaps[i];
          end = safetyCarLaps[i];
        }
      }
      ranges.push({ start, end });
      return ranges;
    }

    function detectRedFlagLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapRedFlag = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRedFlag.has(lapNum)) {
          lapRedFlag.set(lapNum, { total: 0, redFlag: 0 });
        }

        const lapData = lapRedFlag.get(lapNum);
        lapData.total++;

        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('5')) {
          lapData.redFlag++;
        }
      });

      const redFlagLaps = [];
      lapRedFlag.forEach((data, lapNum) => {
        if (data.redFlag / data.total >= 0.5) {
          redFlagLaps.push(lapNum);
        }
      });

      return redFlagLaps.sort((a, b) => a - b);
    }

    function renderRaceTraceChart() {
      if (Object.keys(raceTraceDriverLines).length === 0) return;

      const chartContainer = document.getElementById('raceTraceChart');
      const debugDiv = document.getElementById('raceTraceDebugInfo');
      if (debugDiv) debugDiv.remove();

      if (!raceTraceChart) {
        raceTraceChart = echarts.init(chartContainer);
      }

      const minLap = parseInt(raceTraceLapMin.value);
      const maxLap = parseInt(raceTraceLapMax.value);

      // Detect rainfall, safety car, and red flag laps using unfiltered session data
      const rainfallRanges = detectRainfallLaps(raceTraceCurrentSessionRows, minLap, maxLap);
      const safetyCarRanges = detectSafetyCarLaps(raceTraceCurrentSessionRows, minLap, maxLap);
      const redFlagLaps = detectRedFlagLaps(raceTraceCurrentSessionRows, minLap, maxLap);

      // Calculate gaps by lap for scaling
      const gapsByLap = new Map();
      selectedDrivers.forEach(driver => {
        const data = raceTraceDriverLines[driver];
        if (!data) return;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            if (!gapsByLap.has(lap)) gapsByLap.set(lap, []);
            gapsByLap.get(lap).push(data.gaps[i]);
          }
        }
      });

      const maxGapByLap = new Map();
      gapsByLap.forEach((gaps, lap) => {
        maxGapByLap.set(lap, Math.max(...gaps));
      });

      const series = [];
      const lapCount = Math.max(...Object.values(raceTraceDriverLines).map(d => Math.max(...d.laps)));
      const rightX = (maxLap === lapCount) ? (maxLap + 0.5) : (maxLap + 0.1);

      selectedDrivers.forEach(driver => {
        const data = raceTraceDriverLines[driver];
        if (!data) return;

        const points = [];
        let lastGap = null;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            const rawGap = data.gaps[i];
            const maxGap = maxGapByLap.get(lap) || 0;
            const adjustedGap = rawGap - maxGap;
            points.push([lap, adjustedGap]);
            lastGap = adjustedGap;
          }
        }

        if (points.length > 0) {
          const info = getDriverInfo(driver);
          const completedAllLaps = data.laps.some(lap => lap === maxLap);

          if (completedAllLaps && lastGap !== null) {
            points.push({
              value: [rightX, lastGap],
              tooltip: { show: false },
              emphasis: { disabled: true }
            });
          }

          series.push({
            name: driver,
            type: 'line',
            data: points,
            step: 'end',
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: info.color },
            itemStyle: { color: info.color, borderWidth: 0 },
            emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.5 } },
            blur: { lineStyle: { opacity: 0.15 } },
            endLabel: {
              show: completedAllLaps,
              formatter: '{a}',
              position: 'right',
              offset: [6, 0],
              color: info.color
            },
            animation: false
          });
        }
      });

      // Add rainfall shading
      if (rainfallRanges.length > 0) {
        const markAreaData = rainfallRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end ? `Rainfall (Lap ${range.start})` : `Rainfall (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Rainfall',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: { color: 'rgba(30, 144, 255, 0.1)' },
            data: markAreaData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      // Add safety car shading
      if (safetyCarRanges.length > 0) {
        const markAreaData = safetyCarRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end ? `Safety Car (Lap ${range.start})` : `Safety Car (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Safety Car',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: { color: 'rgba(150, 150, 7, 0.15)' },
            data: markAreaData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      // Add red flag lines
      if (redFlagLaps.length > 0) {
        const markLineData = redFlagLaps.map(lap => ({
          xAxis: lap,
          name: `Red Flag (Lap ${lap})`,
          label: { show: false }
        }));

        series.push({
          name: 'Red Flag',
          type: 'line',
          data: [],
          markLine: {
            silent: false,
            symbol: 'none',
            lineStyle: {
              color: 'rgba(255, 0, 0, 0.5)',
              width: 2,
              type: 'dashed'
            },
            data: markLineData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      const option = {
        backgroundColor: 'transparent',
        grid: {
          left: 60,
          right: 120,
          top: 40,
          bottom: 60,
          containLabel: false
        },
        xAxis: [
          {
            type: 'value',
            name: 'Lap',
            min: minLap,
            max: rightX,
            minInterval: 1,
            nameLocation: 'middle',
            nameGap: 35,
            position: 'bottom',
            axisLine: { lineStyle: { color: '#555' } },
            axisLabel: {
              color: '#aaa',
              formatter: function(value) {
                // Only show label if it's an integer
                return Number.isInteger(value) ? value : '';
              }
            },
            splitLine: {
              show: true,
              lineStyle: { color: '#333', type: 'solid', width: 1 }
            }
          },
          {
            type: 'value',
            min: minLap,
            max: rightX,
            minInterval: 1,
            position: 'top',
            axisLine: { lineStyle: { color: '#555' } },
            axisLabel: {
              color: '#aaa',
              formatter: function(value) {
                // Only show label if it's an integer
                return Number.isInteger(value) ? value : '';
              }
            },
            splitLine: { show: false }
          }
        ],
        yAxis: {
          type: 'value',
          name: 'Gap (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameRotate: 90,
          nameTextStyle: { color: '#aaa', fontSize: 12 },
          minInterval: 1,
          axisLine: { lineStyle: { color: '#555' } },
          axisLabel: { color: '#aaa' },
          splitLine: {
            show: true,
            lineStyle: { color: '#333', type: 'solid', width: 1 }
          }
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          appendToBody: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const v = Array.isArray(p.value) ? p.value : p.data?.value || p.data;
            const lap = Array.isArray(v) ? v[0] : v?.[0];
            const gap = Array.isArray(v) ? v[1] : v?.[1];
            const code = p.seriesName;
            const info = getDriverInfo(code);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || code;
              const teamName = info.teamName || '';
              const gapLine = (typeof lap === 'number' && typeof gap === 'number')
                ? `<div style="margin-top:4px">Lap ${lap}: ${gap.toFixed(3)} s</div>`
                : '';
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${code})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${gapLine}
                  </div>
                </div>
              `;
            }

            if (typeof lap === 'number' && typeof gap === 'number') {
              return `${p.marker}<b>${code}</b><br/>Lap ${lap}: ${gap.toFixed(3)} s`;
            }
            return `${p.marker}<b>${code}</b>`;
          }
        },
        series: series
      };

      raceTraceChart.setOption(option, true); // true = notMerge, completely replace the option
    }

    // Lap Time Panel
    const lapTimeDriversList = document.getElementById('lapTimeDriversList');
    const lapTimeChart = document.getElementById('lapTimeChart');
    const fuelAdjustToggle = document.getElementById('fuelAdjustToggle');
    const tyreLifeAdjustToggle = document.getElementById('tyreLifeAdjustToggle');

    let lapTimeChartInstance = null;
    let lapTimeCurrentGroups = new Map();
    let lapTimeDriverColors = new Map();
    let lapTimeScheduledLaps = null;
    let lapTimeCurrentSessionRows = [];
    let lapTimeYear = '';
    let lapTimeRound = '';
    let lapTimeSessionType = '';
    let circuitConfig = {};

    // Load circuit config
    function loadCircuitConfig() {
      fetch('strat_calc_config.json')
        .then(response => response.json())
        .then(data => {
          circuitConfig = data;
        })
        .catch(err => {
          console.error("Error loading strat_calc_config.json:", err);
        });
    }

    loadCircuitConfig();

    function getLapTimeDriverInfo(code) {
      // Get driver info for current session with proper parameters
      if (!lapTimeYear || !lapTimeRound || !lapTimeSessionType) {
        return { fullName: code, color: '#888888', teamName: '', headshotUrl: '' };
      }

      return DriverInfo.getDriverInfo(code, lapTimeYear, lapTimeRound, lapTimeSessionType);
    }

    // Set up lap time filter listeners
    function setupLapTimeFilterListeners() {
      document.getElementById("filterMinLap").addEventListener("input", onLapTimeFilterChange);
      document.getElementById("filterEndLaps").addEventListener("input", onLapTimeFilterChange);
      document.getElementById("filterMinDist").addEventListener("input", onLapTimeFilterChange);
      document.getElementById("filterRainfall").addEventListener("change", onLapTimeFilterChange);
      document.getElementById("filterSafetyCar").addEventListener("change", onLapTimeFilterChange);
      document.getElementById("filterPitLaps").addEventListener("change", onLapTimeFilterChange);
      document.getElementById('filterIncludeLapped').addEventListener('change', onLapTimeFilterChange);
      document.getElementById('filterIncludeRetired').addEventListener('change', onLapTimeFilterChange);
      document.getElementById('degHard').addEventListener('input', onLapTimeAdjustmentChange);
      document.getElementById('degMedium').addEventListener('input', onLapTimeAdjustmentChange);
      document.getElementById('degSoft').addEventListener('input', onLapTimeAdjustmentChange);
      document.getElementById('fuelEffect').addEventListener('input', onLapTimeAdjustmentChange);

      fuelAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderLapTimeChart();
      });

      tyreLifeAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderLapTimeChart();
      });
    }

    setupLapTimeFilterListeners();

    function onLapTimeFilterChange() {
      if (!currentSessionData || currentSessionData.length === 0) return;
      const filteredRows = applyLapTimeFilters(currentSessionData);
      processLapTimeData(filteredRows);
    }

    function onLapTimeAdjustmentChange() {
      if (lapTimeCurrentGroups.size > 0) {
        renderLapTimeChart();
      }
    }

    function applyLapTimeFilters(rows) {
      const lapsToDiscard = parseInt(document.getElementById("filterMinLap").value) || 0;
      const minLap = lapsToDiscard + 1;
      const endLaps = parseInt(document.getElementById("filterEndLaps").value) || 0;
      const minDist = parseFloat(document.getElementById("filterMinDist").value) || 0;
      const includeRainfall = document.getElementById("filterRainfall").checked;
      const includeSafetyCar = document.getElementById("filterSafetyCar").checked;
      const includePitLaps = document.getElementById("filterPitLaps").checked;
      const includeLapped = document.getElementById('filterIncludeLapped').checked;
      const includeRetired = document.getElementById('filterIncludeRetired').checked;

      return rows.filter(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;

        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }

        const status = String(r.finish_status ?? "").trim();
        const plusLapsMatch = status.match(/^\+(\d+)\sLaps$/);
        const lapsBehind = plusLapsMatch ? Number(plusLapsMatch[1]) : 0;
        if (lapsBehind > 1) return false;

        const isLapped = status === "Lapped" || status === "+1 Lap";
        if (!includeLapped && isLapped) return false;

        const isFinished = status === "Finished" || isLapped;
        const isRetired = !isFinished;
        if (!includeRetired && isRetired) return false;

        if (!includeRainfall) {
          const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
          if (rainfall === "true" || rainfall === "1") return false;
        }

        if (!includeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || "").trim();
          if (trackStatus.includes("4") || trackStatus.includes("5") ||
              trackStatus.includes("6") || trackStatus.includes("7")) {
            return false;
          }
        }

        if (!includePitLaps) {
          const pitIn = String(r.lap_PitInTime || "").trim();
          const pitOut = String(r.lap_PitOutTime || "").trim();
          if ((pitIn && pitIn.toLowerCase() !== "na" && pitIn !== "") ||
              (pitOut && pitOut.toLowerCase() !== "na" && pitOut !== "")) {
            return false;
          }
        }

        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;

        return true;
      });
    }

    function processLapTimeData(rows) {
      if (!rows || rows.length === 0) {
        lapTimeCurrentGroups = new Map();
        lapTimeSelectedDrivers.clear();
        buildLapTimeDriversList([]);
        renderLapTimeChart();
        return;
      }

      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNumber = parseInt(r.lap_LapNumber);
        const lapTime = parseFloat(r.lap_LapTime);
        const compound = String(r.lap_Compound || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const position = parseInt(r.lap_Position);
        const tyreLife = parseInt(r.lap_TyreLife);
        const schedLaps = parseInt(r.sched_laps);

        if (!driver || isNaN(lapNumber) || isNaN(lapTime) || !stint) return;

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            stints: new Map(),
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverData.get(driver);
        const driverStints = data.stints;

        if (!driverStints.has(stint)) {
          driverStints.set(stint, {
            compound: compound,
            laps: []
          });
        }

        driverStints.get(stint).laps.push({
          lapNumber: lapNumber,
          lapTime: lapTime,
          compound: compound,
          tyreLife: tyreLife,
          schedLaps: schedLaps
        });

        if (lapNumber > data.maxLapNum) {
          data.maxLapNum = lapNumber;
          data.lastPosition = position;
        }
      });

      const sortedDrivers = sortDriversByFinishingOrder(Array.from(driverData.values()));

      const sortedDriverData = new Map();
      sortedDrivers.forEach(d => {
        sortedDriverData.set(d.driver, d.stints);
      });
      lapTimeCurrentGroups = sortedDriverData;

      const drivers = sortedDrivers.map(d => d.driver);

      buildLapTimeDriversList(drivers);
      renderLapTimeChart();
    }

    function buildLapTimeDriversList(drivers) {
      lapTimeDriversList.innerHTML = '';

      if (drivers.length === 0) return;

      drivers.forEach(driver => {
        const wrapper = document.createElement('label');
        wrapper.className = 'lap-time-driver-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = driver;
        checkbox.checked = selectedDrivers.has(driver);

        const info = getLapTimeDriverInfo(driver);
        checkbox.style.accentColor = info.color;

        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }
          renderLapTimeChart();
          // Also update race trace chart if it has data
          if (Object.keys(raceTraceDriverLines).length > 0) {
            renderRaceTraceChart();
          }
        });

        const label = document.createElement('label');

        // Format: "Full Name (ABB)"
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        label.textContent = displayName;
        label.style.cursor = 'pointer';
        label.style.color = info.color;

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        lapTimeDriversList.appendChild(wrapper);
      });
    }

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();
      const colorMap = {
        'soft': '#FF0000',
        'medium': '#FFF200',
        'hard': '#FFFFFF',
        'intermediate': '#00FF00',
        'wet': '#0000FF'
      };
      return colorMap[compoundLower] || '#999999';
    }

    function renderLapTimeChart() {
      if (lapTimeCurrentGroups.size === 0) {
        if (lapTimeChartInstance) {
          lapTimeChartInstance.clear();
        }
        return;
      }

      if (!lapTimeChartInstance) {
        lapTimeChartInstance = echarts.init(lapTimeChart);
      }

      const fuelAdjusted = fuelAdjustToggle.classList.contains('active');
      const tyreLifeAdjusted = tyreLifeAdjustToggle.classList.contains('active');
      const fuelEffect = parseFloat(document.getElementById('fuelEffect').value) || 0;
      const degHard = parseFloat(document.getElementById('degHard').value) || 0;
      const degMedium = parseFloat(document.getElementById('degMedium').value) || 0;
      const degSoft = parseFloat(document.getElementById('degSoft').value) || 0;

      const degradationMap = {
        'HARD': degHard,
        'MEDIUM': degMedium,
        'SOFT': degSoft
      };

      const series = [];
      const seriesIndexByDriver = new Map();
      let seriesIdx = 0;

      lapTimeCurrentGroups.forEach((stints, driver) => {
        if (!selectedDrivers.has(driver)) return;

        const stintArray = Array.from(stints.entries()).sort((a, b) => {
          return parseInt(a[0]) - parseInt(b[0]);
        });

        const lastStintIndex = stintArray.length - 1;

        stintArray.forEach(([stintNumber, stintData], stintIndex) => {
          const isLastStint = stintIndex === lastStintIndex;
          const sortedLaps = stintData.laps.slice().sort((a, b) => a.lapNumber - b.lapNumber);

          const data = sortedLaps.map(lap => {
            let adjustedLapTime = lap.lapTime;

            if (fuelAdjusted && !isNaN(lap.schedLaps)) {
              adjustedLapTime -= (lap.schedLaps - lap.lapNumber) * fuelEffect;
            }

            if (tyreLifeAdjusted && !isNaN(lap.tyreLife)) {
              const tyreDeg = degradationMap[lap.compound.toUpperCase()] || 0;
              adjustedLapTime -= lap.tyreLife * tyreDeg;
            }

            return {
              value: [lap.lapNumber, adjustedLapTime],
              driver: driver,
              compound: lap.compound,
              stint: stintNumber,
              originalLapTime: lap.lapTime
            };
          });

          const compound = stintData.compound;
          const compoundColor = getF1TireColor(compound);
          const driverColor = lapTimeDriverColors.get(driver) || '#888888';

          if (!seriesIndexByDriver.has(driver)) {
            seriesIndexByDriver.set(driver, []);
          }
          seriesIndexByDriver.get(driver).push(seriesIdx);

          series.push({
            name: `${driver} - Stint ${stintNumber}`,
            type: 'line',
            data: data,
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: compoundColor },
            triggerLineEvent: true,
            itemStyle: {
              color: driverColor,
              borderColor: driverColor,
              borderWidth: 2
            },
            emphasis: {
              focus: 'none',
              lineStyle: { width: 3 },
              scale: true
            },
            blur: {
              lineStyle: { opacity: 0.05 },
              itemStyle: { opacity: 0.05 }
            },
            endLabel: {
              show: isLastStint,
              formatter: driver,
              position: 'right',
              offset: [6, 0],
              color: driverColor,
              fontSize: 11
            },
            animation: false,
            driver: driver
          });

          seriesIdx++;
        });
      });

      const driverSeriesCount = series.length;

      // Detect rainfall, safety car, and red flag laps for the entire session range
      if (lapTimeCurrentSessionRows.length > 0) {
        // Use the full session lap range (1 to scheduled laps, or max lap in data)
        const minLap = 1;
        const maxLap = lapTimeScheduledLaps || Math.max(...lapTimeCurrentSessionRows.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n)));

        const rainfallRanges = detectRainfallLaps(lapTimeCurrentSessionRows, minLap, maxLap);
        const safetyCarRanges = detectSafetyCarLaps(lapTimeCurrentSessionRows, minLap, maxLap);
        const redFlagLaps = detectRedFlagLaps(lapTimeCurrentSessionRows, minLap, maxLap);

        if (rainfallRanges.length > 0) {
          const markAreaData = rainfallRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Rainfall (Lap ${range.start})`
                : `Rainfall (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Rainfall',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: { color: 'rgba(30, 144, 255, 0.1)' },
              data: markAreaData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }

        if (safetyCarRanges.length > 0) {
          const markAreaData = safetyCarRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Safety Car (Lap ${range.start})`
                : `Safety Car (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Safety Car',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: { color: 'rgba(150, 150, 7, 0.15)' },
              data: markAreaData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }

        if (redFlagLaps.length > 0) {
          const markLineData = redFlagLaps.map(lap => ({
            xAxis: lap,
            name: `Red Flag (Lap ${lap})`,
            label: { show: false }
          }));

          series.push({
            name: 'Red Flag',
            type: 'line',
            data: [],
            markLine: {
              silent: false,
              symbol: 'none',
              lineStyle: {
                color: 'rgba(255, 0, 0, 0.5)',
                width: 2,
                type: 'dotted'
              },
              data: markLineData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }
      }

      if (series.length === 0) {
        lapTimeChartInstance.clear();
        return;
      }

      lapTimeChartInstance.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 100, top: 20, bottom: 60 },
        legend: { show: false },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            const lapNumber = data.value[0];
            const lapTime = data.value[1];
            return `
              <strong>${data.driver}</strong><br/>
              Lap: ${lapNumber}<br/>
              Time: ${lapTime.toFixed(3)}s<br/>
              Compound: ${data.compound}<br/>
              Stint: ${data.stint}
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Lap Number',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          min: 1,
          max: lapTimeScheduledLaps || 'dataMax'
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        series: series
      }, true);

      lapTimeChartInstance.resize();

      // Custom hover behavior
      lapTimeChartInstance.off('mouseover');
      lapTimeChartInstance.off('mouseout');

      let currentHoveredDriver = null;

      lapTimeChartInstance.on('mouseover', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          const hoveredDriver = params.seriesName.split(' - ')[0];

          if (currentHoveredDriver === hoveredDriver) return;
          currentHoveredDriver = hoveredDriver;

          const driverSeriesIndices = seriesIndexByDriver.get(hoveredDriver) || [];

          const updatedSeries = series.map((s, idx) => {
            if (idx >= driverSeriesCount) return {};

            if (driverSeriesIndices.includes(idx)) {
              return {
                lineStyle: { width: 3, color: s.lineStyle.color, opacity: 1 },
                itemStyle: { ...s.itemStyle, opacity: 1 },
                endLabel: { ...s.endLabel, opacity: 1 }
              };
            } else {
              return {
                lineStyle: { width: 2, color: s.lineStyle.color, opacity: 0.15 },
                itemStyle: { ...s.itemStyle, opacity: 0.05 },
                endLabel: { ...s.endLabel, opacity: 0.15 }
              };
            }
          });

          lapTimeChartInstance.setOption({ series: updatedSeries });
        }
      });

      lapTimeChartInstance.on('mouseout', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          currentHoveredDriver = null;

          const resetSeries = series.map((s, idx) => {
            if (idx >= driverSeriesCount) return {};
            return {
              lineStyle: { width: 2, color: s.lineStyle.color, opacity: 1 },
              itemStyle: { ...s.itemStyle, opacity: 1 },
              endLabel: { ...s.endLabel, opacity: 1 }
            };
          });

          lapTimeChartInstance.setOption({ series: resetSeries });
        }
      });
    }

    // Handle window resize for lap time chart
    window.addEventListener('resize', () => {
      if (lapTimeChartInstance) {
        lapTimeChartInstance.resize();
      }
    });

    // Tyre Degradation Panel
    // (Will be populated from tyre_deg.html)

    // Fuel Effect Panel
    // (Will be populated from fuel_effect.html)

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    init();
  </script>
</body>
</html>
